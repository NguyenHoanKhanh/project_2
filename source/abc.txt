`ifndef FETCH_INSTRUCTION_V
`define FETCH_INSTRUCTION_V

module instruction_fetch #(
    parameter IWIDTH = 32,
    parameter AWIDTH_INSTR = 32,
    parameter PC_WIDTH = 32
)(
    f_clk, f_rst, f_i_instr, f_o_instr, f_o_addr_instr, f_change_pc, f_alu_pc_value, 
    f_pc, f_o_syn, f_i_ack, f_i_stall, f_o_ce, f_o_stall, f_i_flush, f_o_flush, f_i_ce,
    f_i_last
);
    input  f_clk, f_rst;
    // Instruction interface
    input  [IWIDTH-1:0] f_i_instr;
    output reg [IWIDTH-1:0] f_o_instr;
    output reg [AWIDTH_INSTR-1:0] f_o_addr_instr;
    output reg f_o_syn;
    input  f_i_ack;
    input  f_i_last;

    // PC
    input  f_change_pc;
    input  [PC_WIDTH-1:0] f_alu_pc_value;
    output reg [PC_WIDTH-1:0] f_pc;

    // Stall / control
    input  f_i_stall;
    output reg f_o_stall;
    input  f_i_ce;
    output reg f_o_ce;
    input  f_i_flush;
    output reg f_o_flush;

    // Internal registered state (only updated in sequential block)
    reg req;                         // outstanding request flag (1 = a request is pending)
    reg [PC_WIDTH-1:0] issued_pc;    // PC tag of the outstanding request
    reg init_done;

    // Next-state (combinational)
    reg next_req;
    reg [PC_WIDTH-1:0] next_issued_pc;
    reg [PC_WIDTH-1:0] next_f_pc;
    reg next_f_o_syn;
    reg next_f_o_ce;
    reg next_f_o_stall;
    reg next_f_o_flush;
    reg [AWIDTH_INSTR-1:0] next_f_o_addr_instr;
    reg [IWIDTH-1:0] next_f_o_instr;

    // Combinational convenience wires
    wire waiting_ack = req && !f_i_ack; // we have a pending request and ack hasn't arrived

    // -------------------------------------------------------------------------
    // Combinational next-state logic
    // -------------------------------------------------------------------------
    always @(*) begin
        // Default: hold current values
        next_req = req;
        next_issued_pc = issued_pc;
        next_f_pc = f_pc;
        next_f_o_syn = 1'b0;
        next_f_o_ce = 1'b0;
        next_f_o_stall = f_o_stall;
        next_f_o_flush = f_o_flush;
        next_f_o_addr_instr = f_o_addr_instr;
        next_f_o_instr = f_o_instr;

        // Default clear outputs unless we set them
        // If flush asserted, cancel pending request and assert flush output
        if (f_i_flush) begin
            next_req = 1'b0;
            next_f_o_syn = 1'b0;
            next_f_o_flush = 1'b1;
            // on flush we do not change PC (could choose to set PC to alu value, but safer to do on ack/change)
        end
        else begin
            // If there is an outstanding request waiting for ack, upstream should be stalled.
            // We only issue a new request when req == 0 (no outstanding) and CE is asserted and not stalled.
            if (!req && f_i_ce && !f_i_stall) begin
                // Start a new request (issue-one/wait)
                next_req = 1'b1;
                next_f_o_syn = 1'b1;         // request the instruction
                next_issued_pc = f_pc;       // tag this request with current PC
                next_f_pc = f_pc + 4;        // advance PC for next potential issue
            end

            // If an ack arrives, consume it and present the instruction to downstream
            if (f_i_ack) begin
                // present returned instruction and its address
                next_f_o_addr_instr = issued_pc;
                next_f_o_instr = f_i_instr;
                next_f_o_ce = 1'b1;

                // If slave indicates last, clear outstanding request
                if (f_i_last) begin
                    next_req = 1'b0;
                    next_f_o_syn = 1'b0;
                end
                else begin
                    // For issue-one/wait policy we clear req and require next cycle to issue again.
                    // Simpler and safer: clear req so new issue happens on next cycle when conditions allow.
                    next_req = 1'b0;
                    next_f_o_syn = 1'b0;
                    // Note: we already advanced next_f_pc when previous issue started.
                end

                // handle change PC on ack: if a change_pc was requested, follow it now
                if (f_change_pc) begin
                    next_f_pc = f_alu_pc_value;
                    // also clear outstanding requests to avoid stale responses being used
                    next_req = 1'b0;
                    next_f_o_syn = 1'b0;
                end
            end
        end

        // Stall output: assert when we have a pending request waiting for ack, or when input stall asserted
        // Also clear stall during flush
        if (f_i_flush) begin
            next_f_o_stall = 1'b0;
        end
        else begin
            next_f_o_stall = (req && !f_i_ack) || f_i_stall;
        end
    end

    // -------------------------------------------------------------------------
    // Sequential update - single place where registers are assigned (non-blocking)
    // -------------------------------------------------------------------------
    always @(posedge f_clk or negedge f_rst) begin
        if (!f_rst) begin
            // reset all registers
            f_pc <= {PC_WIDTH{1'b0}};
            req <= 1'b0;
            issued_pc <= {PC_WIDTH{1'b0}};
            f_o_syn <= 1'b0;
            f_o_ce <= 1'b0;
            f_o_stall <= 1'b0;
            f_o_flush <= 1'b0;
            f_o_addr_instr <= {AWIDTH_INSTR{1'b0}};
            f_o_instr <= {IWIDTH{1'b0}};
            init_done <= 1'b0;
        end
        else begin
            // commit next state
            f_pc <= next_f_pc;
            // When we transition from req==0 to next_req==1 we must latch issued_pc (tag)
            if (!req && next_req) begin
                issued_pc <= next_issued_pc;
            end
            // If ack consumed and last, clear issued_pc (optional)
            if (f_i_ack && f_i_last) begin
                issued_pc <= {PC_WIDTH{1'b0}};
            end

            req <= next_req;
            f_o_syn <= next_f_o_syn;
            f_o_ce <= next_f_o_ce;
            f_o_stall <= next_f_o_stall;
            f_o_flush <= next_f_o_flush;

            if (next_f_o_ce) begin
                f_o_addr_instr <= next_f_o_addr_instr;
                f_o_instr <= next_f_o_instr;
            end
        end
    end

endmodule
`endif
