$date
	Sun Aug 10 16:08:38 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_instruction_fetch $end
$var wire 32 ! f_pc [31:0] $end
$var wire 1 " f_o_syn $end
$var wire 1 # f_o_stall $end
$var wire 32 $ f_o_instr [31:0] $end
$var wire 1 % f_o_flush $end
$var wire 1 & f_o_ce $end
$var wire 32 ' f_o_addr_instr [31:0] $end
$var parameter 32 ( AWIDTH_INSTR $end
$var parameter 32 ) IWIDTH $end
$var parameter 32 * PC_WIDTH $end
$var reg 32 + f_alu_pc_value [31:0] $end
$var reg 1 , f_change_pc $end
$var reg 1 - f_clk $end
$var reg 1 . f_i_ack $end
$var reg 1 / f_i_ce $end
$var reg 1 0 f_i_flush $end
$var reg 32 1 f_i_instr [31:0] $end
$var reg 1 2 f_i_stall $end
$var reg 1 3 f_rst $end
$scope module dut $end
$var wire 32 4 f_alu_pc_value [31:0] $end
$var wire 1 , f_change_pc $end
$var wire 1 - f_clk $end
$var wire 1 . f_i_ack $end
$var wire 1 / f_i_ce $end
$var wire 1 0 f_i_flush $end
$var wire 32 5 f_i_instr [31:0] $end
$var wire 1 2 f_i_stall $end
$var wire 1 " f_o_syn $end
$var wire 1 3 f_rst $end
$var wire 1 6 stall $end
$var parameter 32 7 AWIDTH_INSTR $end
$var parameter 32 8 IWIDTH $end
$var parameter 32 9 PC_WIDTH $end
$var reg 1 " ce $end
$var reg 1 : ce_d $end
$var reg 32 ; f_o_addr_instr [31:0] $end
$var reg 1 & f_o_ce $end
$var reg 1 % f_o_flush $end
$var reg 32 < f_o_instr [31:0] $end
$var reg 1 # f_o_stall $end
$var reg 32 = f_pc [31:0] $end
$var reg 32 > i_addr_instr [31:0] $end
$var reg 1 ? next_ce $end
$var reg 1 @ next_ce_d $end
$var reg 32 A next_i_addr_instr [31:0] $end
$var reg 32 B next_o_addr_instr [31:0] $end
$var reg 1 C next_o_ce $end
$var reg 1 D next_o_flush $end
$var reg 32 E next_o_instr [31:0] $end
$var reg 1 F next_o_stall $end
$var reg 32 G next_pc [31:0] $end
$var reg 32 H next_prev_pc [31:0] $end
$var reg 32 I prev_pc [31:0] $end
$upscope $end
$scope task do_flush $end
$var integer 32 J cycles [31:0] $end
$upscope $end
$scope task do_jump $end
$var reg 32 K pc [31:0] $end
$upscope $end
$scope task do_reset $end
$var integer 32 L cycles [31:0] $end
$upscope $end
$scope task introduce_stall $end
$var integer 32 M cycles [31:0] $end
$upscope $end
$scope task send_instruction $end
$var reg 32 N instr [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 9
b100000 8
b100000 7
b100000 *
b100000 )
b100000 (
$end
#0
$dumpvars
bx N
bx M
b10 L
bx K
bx J
b0 I
b0 H
b0 G
0F
b0 E
0D
0C
b0 B
b0 A
0@
0?
b0 >
b0 =
b0 <
b0 ;
0:
16
b0 5
b0 4
03
02
b0 1
00
0/
0.
0-
0,
b0 +
b0 '
x&
0%
b0 $
0#
0"
b0 !
$end
#5
1-
#10
0-
#15
0&
13
1-
#20
0-
#25
b100 G
1?
1/
1.
b10100000101000001010000010100000 1
b10100000101000001010000010100000 5
b10100000101000001010000010100000 N
1-
#30
0-
#35
b10100000101000001010000010100000 E
16
b100 !
b100 =
1"
b100 G
1?
0.
1-
#40
0-
#45
b10100000101000001010000010100000 $
b10100000101000001010000010100000 <
06
1@
b1000 G
b100 H
b10110001101100011011000110110001 E
1.
b10110001101100011011000110110001 1
b10110001101100011011000110110001 5
b10110001101100011011000110110001 N
1-
#50
0-
#55
b100 A
b100 I
b1000 !
b1000 =
b10110001101100011011000110110001 $
b10110001101100011011000110110001 <
1:
16
b100 H
b10110001101100011011000110110001 E
b1000 G
1@
0.
1-
#60
0-
#65
b100 B
b100 >
1C
06
b1100 G
b1000 H
b11000010110000101100001011000010 E
b100 A
1.
b11000010110000101100001011000010 1
b11000010110000101100001011000010 5
b11000010110000101100001011000010 N
1-
#70
0-
#75
1&
b100 '
b100 ;
b1000 I
b1100 !
b1100 =
b11000010110000101100001011000010 $
b11000010110000101100001011000010 <
16
b1000 H
b11000010110000101100001011000010 E
b100 B
b1100 G
0C
0.
1-
#80
0-
#85
b1000 A
0&
0C
12
b11 M
1-
#90
0-
#95
b1000 B
b1000 >
1-
#100
0-
#105
b1000 '
b1000 ;
1-
#110
0-
#115
02
1-
#120
0-
#125
1C
06
b10000 G
b1100 H
b11010011110100111101001111010011 E
1.
b11010011110100111101001111010011 1
b11010011110100111101001111010011 5
b11010011110100111101001111010011 N
1-
#130
0-
#135
1&
b1100 I
b10000 !
b10000 =
b11010011110100111101001111010011 $
b11010011110100111101001111010011 <
16
b1100 H
b11010011110100111101001111010011 E
b10000 G
0C
0.
1-
#140
0-
#145
0&
b1100 A
06
b100000000 G
b10000 H
1C
0/
1.
1,
b100000000 +
b100000000 4
b100000000 K
1-
#150
0-
#155
1&
b1100 >
b10000 I
b100000000 !
b100000000 =
16
b10000 H
b1100 A
b100000000 G
0C
0.
0,
1-
#160
0-
#165
b1100 B
b10000 A
0&
b11010011110100111101001111010011 E
1F
0D
0?
0C
10
b10 J
1-
#170
0-
#175
b0 E
1D
b1100 '
b1100 ;
b10000 >
1#
0"
1-
#180
0-
#185
b0 $
b0 <
1%
b0 E
1D
00
1-
#190
0-
#195
0@
b100000100 G
b100000000 H
1?
1/
1.
b11100100111001001110010011100100 1
b11100100111001001110010011100100 5
b11100100111001001110010011100100 N
1-
#200
0-
#205
0D
b11100100111001001110010011100100 E
b10000 B
b100000000 A
b100000000 I
b100000100 !
b100000100 =
0:
1"
b100000000 H
b100000100 G
0@
1?
0.
1-
#210
0-
#215
b10000 '
b10000 ;
b100000000 >
b11100100111001001110010011100100 $
b11100100111001001110010011100100 <
0%
1@
b100001000 G
b100000100 H
b11110101111101011111010111110101 E
b100000000 B
b100000000 A
0D
1.
b11110101111101011111010111110101 1
b11110101111101011111010111110101 5
b11110101111101011111010111110101 N
1-
#220
0-
#225
b100000100 A
b100000000 '
b100000000 ;
b100000100 I
b100001000 !
b100001000 =
b11110101111101011111010111110101 $
b11110101111101011111010111110101 <
1:
b100000100 H
b11110101111101011111010111110101 E
b100000000 B
b100001000 G
1@
0.
1-
#230
0-
#235
b100000100 B
b100000100 >
1-
#240
0-
#245
b100000100 '
b100000100 ;
1-
#250
0-
#255
1-
